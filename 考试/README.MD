# 二叉排序树（bst.cpp 时间限制：1s 空间限制 256M 测试方式：忽略行 末空格和测）
## 题目
### 题目描述
```
二叉搜索树在动态查表中有特别的用处，一个无序序列可以通过构造一棵二叉搜索树变成一个有序序列，
构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉搜索树上新的叶子结点，
在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。
规定如果待插入新结点与树上结点值相同，往左子树方向插！这里，我们想探究二叉树的建立和序列输出。
```
### 输入(bst.in)
```
只有一行，包含若干个数，中间用空格隔开。（字可能会有重复）
```
### 输出(bst.out)
```
输出一行，对入数字建立二叉搜索树后进前序 输出一行，对入数字建立二叉搜索树后进前序 遍历的结果。
```
### 样例输入
```
41 467 334 500 169 724 478 358 962 464 705 145 281 827 961 491 995 942 827 436
```
### 样例输出
```
41 467 334 169 145 281 358 464 436 500 478 491 724 705 962 827 827 961 942 995
```
## 分析
```
二叉搜索树的建立、遍历、一本通书上有程序，可以直接用。
```
**特别注意**：
1. 二叉搜索树本身的规则是如果碰到重复的节点就丢弃，但是题目中是允许有重复数字的，所以需要对书上的代码稍作修改，在插入左树时，将大于判断改为大于等于。
2. 输入的时候是没有数量限制的，所以需要使用scanf并判断EOF来确定是否输入结束，并且将输入流定向到文件。

**程序中的关注点**：insert函数的bt参数前面需要使用地址符号&。

# 传话（d.cpp 时间限制：1s 空间限制 128000kb）
## 题目
### 题目描述
```
一个朋友网络，如果a认识b，那么如果a第一次收到某个消息，那么会把这个消息传给b，以及所有a认识的人。 
如果a认识b，b不一定认识a。 所有人从1到n编号，给出所有“认识”关系，问如果i发布一条新消息，
那么会不会经过若干次传话后，这个消息传回给了i，1<=i<=n。
```
### 输入
```
第一行是n和m，表示人数和认识关系数。 接下来的m行，每行两个数a和b，表示a认识b。
1<=a, b<=n。
认识关系可能会重复给出，但一行的两个数不会相同。
```
### 输出
```
一共n行，每行一个字符T或F。
第i行如果是T，表示i发出一条新消息会传回给i；
如果是F，表示i发出一条新消息不会传回给i。
```
---
### 样例输入
```
4 6                        
1 2
2 3
4 1
3 1
1 3
2 3

```
### 样例输出
```
T
T
T
F
```
## 分析
```
这是一道典型的深搜问题。做一个二维数组保存人与人的关系，
数组的第一维是人的编号（类似桶排序），第二维依次保存该人与其他人的关系。
a[t][0]表示第t个人共有多少个邻接点（多少个直接关系人）。
a[t][i] = h表示第t个人的第i个关系人是h。
然后遍历每个人，如果深搜到自己则给结果数组r赋值r[t] = true，表示第t个人可以传回给自己，
如果搜不到则不处理（r数组初始化为全false）。
最后只要循环输出t数组的值即可。
```